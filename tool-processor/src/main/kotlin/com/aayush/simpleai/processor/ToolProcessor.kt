package com.aayush.simpleai.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo
import kotlinx.serialization.json.*
import java.io.File

/**
 * KSP Processor that reads tools.json and generates an Android-compatible
 * tool class with @Tool and @ToolParam annotations.
 */
class ToolProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {
    
    private var processed = false
    
    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (processed) return emptyList()
        processed = true
        
        val toolsJsonPath = options["toolsJsonPath"]
        if (toolsJsonPath == null) {
            logger.warn("toolsJsonPath option not provided, skipping tool generation")
            return emptyList()
        }
        
        val toolsFile = File(toolsJsonPath)
        if (!toolsFile.exists()) {
            logger.warn("tools.json not found at: $toolsJsonPath")
            return emptyList()
        }
        
        try {
            val toolsJson = toolsFile.readText()
            val tools = parseTools(toolsJson)
            
            if (tools.isNotEmpty()) {
                generateToolClass(tools)
                generateToolExecutor(tools)
                logger.info("Generated ${tools.size} tools from tools.json")
            }
        } catch (e: Exception) {
            logger.error("Failed to process tools.json: ${e.message}")
        }
        
        return emptyList()
    }
    
    private fun parseTools(json: String): List<ToolDefinition> {
        val jsonArray = Json.parseToJsonElement(json).jsonArray
        return jsonArray.mapNotNull { element ->
            try {
                val obj = element.jsonObject
                if (obj["type"]?.jsonPrimitive?.content != "function") return@mapNotNull null
                
                val function = obj["function"]?.jsonObject ?: return@mapNotNull null
                val name = function["name"]?.jsonPrimitive?.content ?: return@mapNotNull null
                val description = function["description"]?.jsonPrimitive?.content ?: ""
                
                val parameters = mutableListOf<ToolParameter>()
                val paramsObj = function["parameters"]?.jsonObject
                val properties = paramsObj?.get("properties")?.jsonObject
                val required = paramsObj?.get("required")?.jsonArray?.map { 
                    it.jsonPrimitive.content 
                } ?: emptyList()
                
                properties?.forEach { (paramName, paramValue) ->
                    val paramObj = paramValue.jsonObject
                    val type = paramObj["type"]?.jsonPrimitive?.content ?: "string"
                    val paramDesc = paramObj["description"]?.jsonPrimitive?.content ?: ""
                    val isRequired = paramName in required
                    
                    parameters.add(ToolParameter(
                        name = paramName,
                        type = type,
                        description = paramDesc,
                        required = isRequired
                    ))
                }
                
                ToolDefinition(name, description, parameters)
            } catch (e: Exception) {
                logger.warn("Failed to parse tool: ${e.message}")
                null
            }
        }
    }
    
    private fun generateToolClass(tools: List<ToolDefinition>) {
        val toolAnnotation = ClassName("com.google.ai.edge.litertlm", "Tool")
        val toolParamAnnotation = ClassName("com.google.ai.edge.litertlm", "ToolParam")
        
        val classBuilder = TypeSpec.classBuilder("GeneratedToolSet")
            .addKdoc("Auto-generated tool set from tools.json.\nDO NOT EDIT - this file is generated by KSP.")
        
        for (tool in tools) {
            val funBuilder = FunSpec.builder(tool.name.snakeToCamelCase())
                .addAnnotation(AnnotationSpec.builder(toolAnnotation)
                    .addMember("description = %S", tool.description)
                    .build())
                .returns(String::class)
            
            for (param in tool.parameters) {
                val paramType = when (param.type) {
                    "string" -> String::class.asTypeName()
                    "integer" -> Int::class.asTypeName()
                    "number" -> Double::class.asTypeName()
                    "boolean" -> Boolean::class.asTypeName()
                    else -> String::class.asTypeName()
                }.copy(nullable = !param.required)
                
                funBuilder.addParameter(
                    ParameterSpec.builder(param.name.snakeToCamelCase(), paramType)
                        .addAnnotation(AnnotationSpec.builder(toolParamAnnotation)
                            .addMember("description = %S", param.description)
                            .build())
                        .apply {
                            if (!param.required) {
                                defaultValue("null")
                            }
                        }
                        .build()
                )
            }
            
            // Generate function body that delegates to ToolExecutor
            val paramNames = tool.parameters.map { it.name.snakeToCamelCase() }
            val paramsMap = if (paramNames.isNotEmpty()) {
                "mapOf(${paramNames.joinToString { "\"${it}\" to ${it}" }})"
            } else {
                "emptyMap()"
            }
            
            funBuilder.addStatement("return ToolExecutor.execute(%S, $paramsMap)", tool.name)
            classBuilder.addFunction(funBuilder.build())
        }
        
        val fileSpec = FileSpec.builder("com.aayush.simpleai.generated", "GeneratedToolSet")
            .addType(classBuilder.build())
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
    
    private fun generateToolExecutor(tools: List<ToolDefinition>) {
        // Import CommonToolExecutor from the util package
        val commonToolExecutor = ClassName("com.aayush.simpleai.util", "CommonToolExecutor")
        
        val objectBuilder = TypeSpec.objectBuilder("ToolExecutor")
            .addKdoc("Delegates tool execution to CommonToolExecutor in commonMain.\nAuto-generated from tools.json - DO NOT EDIT.")
        
        val executeFunc = FunSpec.builder("execute")
            .addParameter("toolName", String::class)
            .addParameter("params", ClassName("kotlin.collections", "Map")
                .parameterizedBy(String::class.asTypeName(), ANY.copy(nullable = true)))
            .returns(String::class)
            .addStatement("return %T.execute(toolName, params)", commonToolExecutor)
        
        objectBuilder.addFunction(executeFunc.build())
        
        val fileSpec = FileSpec.builder("com.aayush.simpleai.generated", "ToolExecutor")
            .addType(objectBuilder.build())
            .build()
        
        fileSpec.writeTo(codeGenerator, Dependencies(false))
    }
    
    private fun String.snakeToCamelCase(): String {
        return split("_").mapIndexed { index, part ->
            if (index == 0) part.lowercase()
            else part.replaceFirstChar { it.uppercase() }
        }.joinToString("")
    }
    
    private fun String.snakeToPascalCase(): String {
        return split("_").joinToString("") { part ->
            part.replaceFirstChar { it.uppercase() }
        }
    }
    
    private fun String.capitalize(): String {
        return replaceFirstChar { it.uppercase() }
    }
}

data class ToolDefinition(
    val name: String,
    val description: String,
    val parameters: List<ToolParameter>
)

data class ToolParameter(
    val name: String,
    val type: String,
    val description: String,
    val required: Boolean
)

class ToolProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ToolProcessor(
            environment.codeGenerator,
            environment.logger,
            environment.options
        )
    }
}

#!/bin/bash
# Build script for LiteRT-LM iOS static framework
# 
# This script builds the LiteRT-LM C API as a "thick" static framework for iOS.
#
# The script automatically patches the LiteRT-LM BUILD file to add an
# ios_static_framework target, builds it, extracts the framework, and restores
# the original BUILD file.
# 
# Usage:
#   ./build_ios.sh
#
# Output:
#   The built frameworks will be placed in:
#   - iosApp/build/ios_sim_arm64/LiteRtLm.framework (simulator)
#   - iosApp/build/ios_sim_arm64/GemmaModelConstraintProvider.framework (simulator)
#   - iosApp/build/ios_arm64/LiteRtLm.framework (device)
#   - iosApp/build/ios_arm64/GemmaModelConstraintProvider.framework (device)
#   - iosApp/build/ios_xcframework/LiteRtLm.xcframework (universal, if --all)
#   - iosApp/build/ios_xcframework/GemmaModelConstraintProvider.xcframework (universal, if --all)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="${SCRIPT_DIR}/.."
IOS_APP_ROOT="${PROJECT_DIR}/iosApp"
BUILD_DIR="${IOS_APP_ROOT}/build"

# Default LiteRT-LM directory (assuming it's in the parent directory)
LITERTLM_DIR="${PROJECT_DIR}/LiteRT-LM"

# Track if we've patched the BUILD file
BUILD_FILE_PATCHED=false
ENGINE_FILES_PATCHED=false
ORIGINAL_BUILD_FILE=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Global flags
NEED_WRAPPED_CLANG_FIX=false
CLEAN_BUILD=false

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check for required tools
check_requirements() {
    if ! command -v bazel &> /dev/null && ! command -v bazelisk &> /dev/null; then
        log_error "Bazel or Bazelisk is required but not installed."
        log_info "Install Bazelisk: brew install bazelisk"
        exit 1
    fi
    
    # Use bazelisk if available, otherwise bazel
    if command -v bazelisk &> /dev/null; then
        BAZEL_CMD="bazelisk"
    else
        BAZEL_CMD="bazel"
    fi
    
    log_info "Using: $BAZEL_CMD"
}

# Xcode 16+ / macOS Tahoe compatibility workaround
setup_xcode_compat() {
    log_info "Checking Xcode version..."
    XCODE_VERSION=$(xcodebuild -version | head -1 | awk '{print $2}')
    log_info "Detected Xcode version: $XCODE_VERSION"
    
    # Set environment variable to help with Xcode compatibility
    export DEVELOPER_DIR="$(xcode-select -p)"
    
    MAJOR_VERSION=$(echo "$XCODE_VERSION" | cut -d. -f1)
    if [ "$MAJOR_VERSION" -ge 16 ]; then
        log_warn "Xcode 16+ detected. Using compatibility flags..."
        EXTRA_FLAGS="--xcode_version=${XCODE_VERSION} --macos_sdk_version=$(xcrun --show-sdk-version)"
    else
        EXTRA_FLAGS=""
    fi
}

# Patch LiteRT-LM BUILD file to add ios_static_framework target
patch_build_file() {
    local BUILD_FILE="${LITERTLM_DIR}/c/BUILD"
    
    # Check if BUILD file exists (could be BUILD or BUILD.bazel)
    if [ ! -f "${BUILD_FILE}" ]; then
        BUILD_FILE="${LITERTLM_DIR}/c/BUILD.bazel"
    fi
    
    if [ ! -f "${BUILD_FILE}" ]; then
        log_error "Cannot find BUILD file in ${LITERTLM_DIR}/c/"
        return 1
    fi
    
    ORIGINAL_BUILD_FILE="${BUILD_FILE}"
    
    # Check if already patched (has ios_static_framework)
    if grep -q 'name = "LiteRtLm"' "${BUILD_FILE}" 2>/dev/null; then
        log_info "BUILD file already has LiteRtLm target. No patching needed."
        BUILD_FILE_PATCHED=false
        return 0
    fi
    
    log_info "Patching BUILD file to add ios_static_framework target..."
    
    # Create backup
    cp "${BUILD_FILE}" "${BUILD_FILE}.backup"
    
    # Check if we need to add the load statement
    if ! grep -q 'ios_static_framework' "${BUILD_FILE}"; then
        # Add load statement at the top (after any existing load statements or at the very top)
        local LOAD_STMT='load("@build_bazel_rules_apple//apple:ios.bzl", "ios_static_framework")'
        
        # Create a temp file with the load statement prepended
        {
            echo "${LOAD_STMT}"
            echo ""
            cat "${BUILD_FILE}"
        } > "${BUILD_FILE}.tmp"
        mv "${BUILD_FILE}.tmp" "${BUILD_FILE}"
    fi
    
    # Append the ios_static_framework target
    cat >> "${BUILD_FILE}" << 'EOF'

# iOS static framework that bundles all dependencies into a single archive.
# This is needed because Swift/Xcode can't easily link against thin Bazel libraries.
# (Auto-generated by SimpleAI build_ios.sh)
ios_static_framework(
    name = "LiteRtLm",
    hdrs = ["engine.h"],
    bundle_name = "LiteRtLm",
    minimum_os_version = "13.0",
    visibility = ["//visibility:public"],
    deps = [":engine"],
)
EOF
    
    BUILD_FILE_PATCHED=true
    log_info "BUILD file patched successfully."
}

# Patch engine.h and engine.cc to add RunPrefill and RunDecode to C API
# (These are needed because the high-level Conversation API doesn't support
# history restoration, so we use low-level Session API instead).
patch_engine_files() {
    local ENGINE_H="${LITERTLM_DIR}/c/engine.h"
    local ENGINE_CC="${LITERTLM_DIR}/c/engine.cc"

    if grep -q "litert_lm_session_run_prefill" "${ENGINE_H}" 2>/dev/null; then
        log_info "Engine files already patched. No patching needed."
        ENGINE_FILES_PATCHED=false
        return 0
    fi

    log_info "Patching engine.h and engine.cc to add RunPrefill and RunDecode..."

    # Create backups
    cp "${ENGINE_H}" "${ENGINE_H}.backup"
    cp "${ENGINE_CC}" "${ENGINE_CC}.backup"

    # Patch engine.h
    # Insert before litert_lm_responses_delete
    # macOS sed is picky: 'i' needs a newline after it
    sed -i '' '/void litert_lm_responses_delete(LiteRtLmResponses\* responses);/i\
\
LITERT_LM_C_API_EXPORT \\\
void litert_lm_session_run_prefill(LiteRtLmSession* session, \\\
                                  const InputData* inputs, \\\
                                  size_t num_inputs); \\\
\\\
LITERT_LM_C_API_EXPORT \\\
LiteRtLmResponses* litert_lm_session_run_decode(LiteRtLmSession* session); \
' "${ENGINE_H}"

    # Patch engine.cc
    # We want to insert the implementation before litert_lm_session_generate_content_stream
    cat > "${ENGINE_CC}.patch" << 'EOF'

void litert_lm_session_run_prefill(LiteRtLmSession* session,
                                  const InputData* inputs,
                                  size_t num_inputs) {
  if (!session || !session->session) {
    return;
  }
  std::vector<std::variant<litert::lm::InputText, litert::lm::InputImage,
                           litert::lm::InputAudio, litert::lm::InputAudioEnd>>
      engine_inputs;
  engine_inputs.reserve(num_inputs);
  for (size_t i = 0; i < num_inputs; ++i) {
    switch (inputs[i].type) {
      case kInputText:
        engine_inputs.emplace_back(InputText(std::string(
            static_cast<const char*>(inputs[i].data), inputs[i].size)));
        break;
      case kInputImage:
        engine_inputs.emplace_back(litert::lm::InputImage(std::string(
            static_cast<const char*>(inputs[i].data), inputs[i].size)));
        break;
      case kInputAudio:
        engine_inputs.emplace_back(litert::lm::InputAudio(std::string(
            static_cast<const char*>(inputs[i].data), inputs[i].size)));
        break;
      case kInputAudioEnd:
        engine_inputs.emplace_back(litert::lm::InputAudioEnd());
        break;
    }
  }
  auto status = session->session->RunPrefill(std::move(engine_inputs));
  if (!status.ok()) {
    ABSL_LOG(ERROR) << "Failed to run prefill: " << status;
  }
}

LiteRtLmResponses* litert_lm_session_run_decode(LiteRtLmSession* session) {
  if (!session || !session->session) {
    return nullptr;
  }
  auto responses = session->session->RunDecode();
  if (!responses.ok()) {
    ABSL_LOG(ERROR) << "Failed to run decode: " << responses.status();
    return nullptr;
  }

  auto* c_responses = new LiteRtLmResponses{std::move(*responses)};
  return c_responses;
}
EOF

    # Insert implementation before litert_lm_session_generate_content_stream
    # Using a temporary file and 'sed' with the 'r' command is safest on macOS
    sed -i '' '/int litert_lm_session_generate_content_stream/ {
i\

r '"${ENGINE_CC}.patch"'
}' "${ENGINE_CC}"
    rm "${ENGINE_CC}.patch"

    ENGINE_FILES_PATCHED=true
    log_info "Engine files patched successfully."
}

# Restore the original engine files
restore_engine_files() {
    if [ "${ENGINE_FILES_PATCHED}" = true ]; then
        local ENGINE_H="${LITERTLM_DIR}/c/engine.h"
        local ENGINE_CC="${LITERTLM_DIR}/c/engine.cc"
        if [ -f "${ENGINE_H}.backup" ]; then
            log_info "Restoring original engine.h..."
            mv "${ENGINE_H}.backup" "${ENGINE_H}"
        fi
        if [ -f "${ENGINE_CC}.backup" ]; then
            log_info "Restoring original engine.cc..."
            mv "${ENGINE_CC}.backup" "${ENGINE_CC}"
        fi
        ENGINE_FILES_PATCHED=false
    fi
}

# Restore the original BUILD file
restore_build_file() {
    if [ "${BUILD_FILE_PATCHED}" = true ] && [ -n "${ORIGINAL_BUILD_FILE}" ]; then
        if [ -f "${ORIGINAL_BUILD_FILE}.backup" ]; then
            log_info "Restoring original BUILD file..."
            mv "${ORIGINAL_BUILD_FILE}.backup" "${ORIGINAL_BUILD_FILE}"
            BUILD_FILE_PATCHED=false
        fi
    fi
    restore_engine_files
}

# Cleanup function to ensure BUILD file is restored on exit
cleanup() {
    restore_build_file
}

# Set up trap to restore BUILD file on script exit
trap cleanup EXIT

# Clean bazel caches
clean_bazel_caches() {
    log_info "Cleaning bazel build caches..."

    BAZEL_CACHE_DIR="/private/var/tmp/_bazel_$(whoami)"

    if [ -d "${BAZEL_CACHE_DIR}" ]; then
        log_info "Removing ${BAZEL_CACHE_DIR}..."
        # Fix permissions first (bazel sets some files as read-only)
        chmod -R +w "${BAZEL_CACHE_DIR}" 2>/dev/null || true
        rm -rf "${BAZEL_CACHE_DIR}" 2>/dev/null || {
            log_warn "Could not fully remove bazel cache. Trying with sudo..."
            sudo rm -rf "${BAZEL_CACHE_DIR}" 2>/dev/null || log_warn "Failed to remove bazel cache - may need manual cleanup"
        }
        log_info "Bazel cache cleaned."
    else
        log_info "No bazel cache found at ${BAZEL_CACHE_DIR}"
    fi

    # Also clean bazel output in the LiteRT-LM directory
    if [ -d "${LITERTLM_DIR}" ]; then
        cd "${LITERTLM_DIR}"
        if [ -n "${BAZEL_CMD}" ]; then
            log_info "Running bazel clean in ${LITERTLM_DIR}..."
            ${BAZEL_CMD} clean --expunge 2>/dev/null || true
        fi
    fi
}

# Fix wrapped_clang for macOS Tahoe (26+) / Xcode 26+
# The dyld on macOS Tahoe requires LC_UUID load command which is missing
# from the wrapped_clang binary built by Bazel's apple_support.
fix_wrapped_clang() {
    log_info "Checking for LC_UUID compatibility issue..."
    
    BAZEL_CACHE_DIR="/private/var/tmp/_bazel_$(whoami)"
    
    if [ ! -d "${BAZEL_CACHE_DIR}" ]; then
        log_info "No bazel cache found. Will fix after first build attempt."
        NEED_WRAPPED_CLANG_FIX=true
        return 0
    fi
    
    # Find the wrapped_clang source
    local WRAPPED_CLANG_SOURCE=$(find "${BAZEL_CACHE_DIR}" -path "*apple_support/crosstool/wrapped_clang.cc" -type f 2>/dev/null | head -1)
    
    if [ -z "${WRAPPED_CLANG_SOURCE}" ]; then
        log_info "No wrapped_clang source found (first build or cache cleared). Will fix after first build attempt."
        NEED_WRAPPED_CLANG_FIX=true
        return 0
    fi
    
    # Find ALL wrapped_clang and wrapped_clang_pp binaries
    local WRAPPED_BINARIES=$(find "${BAZEL_CACHE_DIR}" -path "*local_config_apple_cc/wrapped_clang*" -type f 2>/dev/null)
    
    if [ -z "${WRAPPED_BINARIES}" ]; then
        log_info "No wrapped_clang binaries found. Will fix after first build attempt."
        NEED_WRAPPED_CLANG_FIX=true
        return 0
    fi
    
    # Check and fix each binary
    local NEEDS_FIX=false
    local FIXED_COUNT=0
    
    while IFS= read -r BINARY; do
        [ -z "${BINARY}" ] && continue
        
        if ! otool -l "${BINARY}" 2>/dev/null | grep -q "LC_UUID"; then
            NEEDS_FIX=true
            log_warn "$(basename "${BINARY}") is missing LC_UUID. Rebuilding with fix..."
            
            clang++ -std=c++17 -O2 -Wl,-random_uuid -arch x86_64 -arch arm64 \
                "${WRAPPED_CLANG_SOURCE}" -o "${BINARY}" 2>&1
            
            if [ $? -eq 0 ]; then
                log_info "Successfully rebuilt $(basename "${BINARY}") with LC_UUID"
                ((FIXED_COUNT++))
            else
                log_error "Failed to rebuild $(basename "${BINARY}")"
            fi
        fi
    done <<< "${WRAPPED_BINARIES}"
    
    if [ "${NEEDS_FIX}" = false ]; then
        log_info "All wrapped_clang binaries already have LC_UUID. No fix needed."
    elif [ ${FIXED_COUNT} -gt 0 ]; then
        log_info "Fixed ${FIXED_COUNT} wrapped_clang binary(ies)"
    fi
    
    NEED_WRAPPED_CLANG_FIX=false
}

# Fix all wrapped_clang binaries in the bazel cache
fix_all_wrapped_clang() {
    local BAZEL_CACHE_DIR="/private/var/tmp/_bazel_$(whoami)"
    
    # Find the source file (only need one)
    local WRAPPED_CLANG_SOURCE=$(find "${BAZEL_CACHE_DIR}" -path "*apple_support/crosstool/wrapped_clang.cc" -type f 2>/dev/null | head -1)
    
    if [ -z "${WRAPPED_CLANG_SOURCE}" ]; then
        log_error "Could not find wrapped_clang.cc source file"
        return 1
    fi
    
    log_info "Found wrapped_clang source: ${WRAPPED_CLANG_SOURCE}"
    
    # Find ALL wrapped_clang and wrapped_clang_pp binaries (not just the first one)
    local WRAPPED_BINARIES=$(find "${BAZEL_CACHE_DIR}" -path "*local_config_apple_cc/wrapped_clang*" -type f 2>/dev/null)
    
    if [ -z "${WRAPPED_BINARIES}" ]; then
        log_error "Could not find any wrapped_clang binaries"
        return 1
    fi
    
    local FIX_COUNT=0
    while IFS= read -r BINARY; do
        # Skip if empty
        [ -z "${BINARY}" ] && continue
        
        # Check if this binary needs fixing
        if ! otool -l "${BINARY}" 2>/dev/null | grep -q "LC_UUID"; then
            log_info "Fixing: ${BINARY}"
            clang++ -std=c++17 -O2 -Wl,-random_uuid -arch x86_64 -arch arm64 \
                "${WRAPPED_CLANG_SOURCE}" -o "${BINARY}" 2>&1 || {
                log_warn "Failed to fix ${BINARY}"
                continue
            }
            ((FIX_COUNT++))
        fi
    done <<< "${WRAPPED_BINARIES}"
    
    if [ ${FIX_COUNT} -gt 0 ]; then
        log_info "Fixed ${FIX_COUNT} wrapped_clang binary(ies) with LC_UUID"
    fi
    
    return 0
}

# Try build with wrapped_clang fix if needed
try_build_with_fix() {
    local BUILD_CMD="$1"
    local LOG_FILE="$2"
    
    # First attempt
    set +e  # Temporarily disable exit on error
    eval "${BUILD_CMD}" 2>&1 | tee "${LOG_FILE}"
    # IMPORTANT: Use PIPESTATUS[0] to get exit code of the first command in pipeline,
    # not $? which gives exit code of tee (always 0)
    local BUILD_RESULT=${PIPESTATUS[0]}
    set -e
    
    if [ $BUILD_RESULT -eq 0 ]; then
        return 0
    fi
    
    # Check if it failed due to LC_UUID issue
    if grep -q "missing LC_UUID load command" "${LOG_FILE}" 2>/dev/null; then
        log_warn "Build failed due to LC_UUID issue. Applying fix..."
        
        # Fix ALL wrapped_clang binaries
        if fix_all_wrapped_clang; then
            log_info "Retrying build..."
            set +e
            eval "${BUILD_CMD}" 2>&1 | tee "${LOG_FILE}"
            BUILD_RESULT=${PIPESTATUS[0]}
            set -e
            
            if [ $BUILD_RESULT -eq 0 ]; then
                return 0
            fi
        fi
    fi
    
    return 1
}

# Create a framework from a dylib
create_dylib_framework() {
    local DYLIB_PATH="$1"
    local FRAMEWORK_NAME="$2"
    local OUTPUT_DIR="$3"
    local PLATFORM="$4"  # "iPhoneOS" or "iPhoneSimulator"
    
    if [ ! -f "${DYLIB_PATH}" ]; then
        log_warn "Dylib not found: ${DYLIB_PATH}"
        return 1
    fi
    
    local FRAMEWORK_DIR="${OUTPUT_DIR}/${FRAMEWORK_NAME}.framework"
    
    log_info "Creating ${FRAMEWORK_NAME}.framework from dylib..."
    
    # Clean and create framework structure
    rm -rf "${FRAMEWORK_DIR}"
    mkdir -p "${FRAMEWORK_DIR}/Headers"
    mkdir -p "${FRAMEWORK_DIR}/Modules"
    
    # Copy the dylib as the framework binary
    cp "${DYLIB_PATH}" "${FRAMEWORK_DIR}/${FRAMEWORK_NAME}"
    
    # Update the install name to match framework structure
    install_name_tool -id "@rpath/${FRAMEWORK_NAME}.framework/${FRAMEWORK_NAME}" \
        "${FRAMEWORK_DIR}/${FRAMEWORK_NAME}" 2>/dev/null || true
    
    # Create module.modulemap
    cat > "${FRAMEWORK_DIR}/Modules/module.modulemap" << EOF
framework module ${FRAMEWORK_NAME} {
    header "${FRAMEWORK_NAME}.h"
    export *
}
EOF
    
    # Create a minimal header file
    cat > "${FRAMEWORK_DIR}/Headers/${FRAMEWORK_NAME}.h" << EOF
// ${FRAMEWORK_NAME} Framework
// Auto-generated header for dynamic library framework wrapper

#ifndef ${FRAMEWORK_NAME}_h
#define ${FRAMEWORK_NAME}_h

// This framework wraps the ${FRAMEWORK_NAME} dynamic library.
// The library provides constrained decoding support for Gemma models.

#endif /* ${FRAMEWORK_NAME}_h */
EOF
    
    # Create Info.plist
    cat > "${FRAMEWORK_DIR}/Info.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>en</string>
    <key>CFBundleExecutable</key>
    <string>${FRAMEWORK_NAME}</string>
    <key>CFBundleIdentifier</key>
    <string>com.google.ai.edge.${FRAMEWORK_NAME}</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>${FRAMEWORK_NAME}</string>
    <key>CFBundlePackageType</key>
    <string>FMWK</string>
    <key>CFBundleShortVersionString</key>
    <string>0.8.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>CFBundleSupportedPlatforms</key>
    <array>
        <string>${PLATFORM}</string>
    </array>
    <key>MinimumOSVersion</key>
    <string>13.0</string>
</dict>
</plist>
EOF
    
    log_info "Created ${FRAMEWORK_DIR}"
    return 0
}

# Create LiteRtLm.framework from static library
create_litertlm_framework() {
    local STATIC_LIB="$1"
    local OUTPUT_DIR="$2"
    local PLATFORM="$3"  # "iPhoneOS" or "iPhoneSimulator"
    
    local FRAMEWORK_DIR="${OUTPUT_DIR}/LiteRtLm.framework"
    
    log_info "Creating LiteRtLm.framework..."
    
    # Clean and create framework structure
    rm -rf "${FRAMEWORK_DIR}"
    mkdir -p "${FRAMEWORK_DIR}/Headers"
    mkdir -p "${FRAMEWORK_DIR}/Modules"
    
    # Copy the static library as the framework binary
    cp "${STATIC_LIB}" "${FRAMEWORK_DIR}/LiteRtLm"
    
    # Copy headers
    cp "${LITERTLM_DIR}/c/engine.h" "${FRAMEWORK_DIR}/Headers/"
    cp "${LITERTLM_DIR}/c/litert_lm_logging.h" "${FRAMEWORK_DIR}/Headers/" 2>/dev/null || true
    
    # Create umbrella header
    cat > "${FRAMEWORK_DIR}/Headers/LiteRtLm.h" << 'EOF'
// LiteRtLm Framework
// Umbrella header for LiteRT LM C API

#ifndef LiteRtLm_h
#define LiteRtLm_h

#include "engine.h"

#endif /* LiteRtLm_h */
EOF
    
    # Create module.modulemap
    cat > "${FRAMEWORK_DIR}/Modules/module.modulemap" << 'EOF'
framework module LiteRtLm {
  umbrella header "LiteRtLm.h"
  export *
  module * { export * }
  link "System"
  link "dl"
  link "m"
  link "objc"
  link "pthread"
  link "resolv"
  link framework "AVFoundation"
  link framework "AudioToolbox"
  link framework "CoreFoundation"
  link framework "Foundation"
  link framework "Metal"
  link framework "Security"
}
EOF
    
    # Add Info.plist
    add_framework_info_plist "${FRAMEWORK_DIR}" "${PLATFORM}"
    
    log_info "Created ${FRAMEWORK_DIR}"
}

# Build for iOS Simulator
build_simulator() {
    log_info "Building for iOS Simulator (arm64)..."
    
    cd "${LITERTLM_DIR}"
    
    # Clean previous build
    rm -rf "${BUILD_DIR}/ios_sim_arm64"
    mkdir -p "${BUILD_DIR}/ios_sim_arm64"
    
    # Patch the BUILD file to add ios_static_framework target
    patch_build_file
    patch_engine_files
    
    # Try to fix wrapped_clang before build
    fix_wrapped_clang
    
    # Build command - build the ios_static_framework (thick library with all deps)
    BUILD_CMD="${BAZEL_CMD} build \
        --config=ios_sim_arm64 \
        --compilation_mode=opt \
        --copt=-fembed-bitcode \
        --apple_generate_dsym=false \
        ${EXTRA_FLAGS} \
        //c:LiteRtLm"
    
    # Build with auto-fix for LC_UUID issue
    if ! try_build_with_fix "${BUILD_CMD}" "${BUILD_DIR}/ios_sim_arm64/build.log"; then
        log_error "Simulator build failed. Check ${BUILD_DIR}/ios_sim_arm64/build.log for details."
        exit 1
    fi
    
    # Extract the framework from the zip
    BAZEL_BIN="${LITERTLM_DIR}/bazel-bin"
    
    if [ -f "${BAZEL_BIN}/c/LiteRtLm.zip" ]; then
        log_info "Extracting LiteRtLm.framework from zip..."
        unzip -o "${BAZEL_BIN}/c/LiteRtLm.zip" -d "${BUILD_DIR}/ios_sim_arm64/"
        
        # Add Info.plist if not present (needed for XCFramework creation)
        add_framework_info_plist "${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework" "iPhoneSimulator"
        
        log_info "Framework extracted to ${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework"
    else
        log_error "LiteRtLm.zip not found at ${BAZEL_BIN}/c/LiteRtLm.zip"
        log_error "The ios_static_framework build may have failed."
        exit 1
    fi
    
    # Create GemmaModelConstraintProvider.framework from prebuilt dylib
    if [ -f "${LITERTLM_DIR}/prebuilt/ios_sim_arm64/libGemmaModelConstraintProvider.dylib" ]; then
        create_dylib_framework \
            "${LITERTLM_DIR}/prebuilt/ios_sim_arm64/libGemmaModelConstraintProvider.dylib" \
            "GemmaModelConstraintProvider" \
            "${BUILD_DIR}/ios_sim_arm64" \
            "iPhoneSimulator"
    else
        log_warn "Prebuilt GemmaModelConstraintProvider dylib not found for simulator"
    fi
    
    log_info "iOS Simulator build complete: ${BUILD_DIR}/ios_sim_arm64/"
}

# Build for iOS Device
build_device() {
    log_info "Building for iOS Device (arm64)..."
    
    cd "${LITERTLM_DIR}"
    
    # Clean previous build
    rm -rf "${BUILD_DIR}/ios_arm64"
    mkdir -p "${BUILD_DIR}/ios_arm64"
    
    # Patch the BUILD file to add ios_static_framework target
    patch_build_file
    patch_engine_files
    
    # Try to fix wrapped_clang before build
    fix_wrapped_clang
    
    # Build command - build the ios_static_framework (thick library with all deps)
    BUILD_CMD="${BAZEL_CMD} build \
        --config=ios_arm64 \
        --compilation_mode=opt \
        --copt=-fembed-bitcode \
        --apple_generate_dsym=false \
        ${EXTRA_FLAGS} \
        //c:LiteRtLm"
    
    # Build with auto-fix for LC_UUID issue
    if ! try_build_with_fix "${BUILD_CMD}" "${BUILD_DIR}/ios_arm64/build.log"; then
        log_error "Device build failed. Check ${BUILD_DIR}/ios_arm64/build.log for details."
        exit 1
    fi
    
    # Extract the framework from the zip
    BAZEL_BIN="${LITERTLM_DIR}/bazel-bin"
    
    if [ -f "${BAZEL_BIN}/c/LiteRtLm.zip" ]; then
        log_info "Extracting LiteRtLm.framework from zip..."
        unzip -o "${BAZEL_BIN}/c/LiteRtLm.zip" -d "${BUILD_DIR}/ios_arm64/"
        
        # Add Info.plist if not present (needed for XCFramework creation)
        add_framework_info_plist "${BUILD_DIR}/ios_arm64/LiteRtLm.framework" "iPhoneOS"
        
        log_info "Framework extracted to ${BUILD_DIR}/ios_arm64/LiteRtLm.framework"
    else
        log_error "LiteRtLm.zip not found at ${BAZEL_BIN}/c/LiteRtLm.zip"
        log_error "The ios_static_framework build may have failed."
        exit 1
    fi
    
    # Create GemmaModelConstraintProvider.framework from prebuilt dylib
    if [ -f "${LITERTLM_DIR}/prebuilt/ios_arm64/libGemmaModelConstraintProvider.dylib" ]; then
        create_dylib_framework \
            "${LITERTLM_DIR}/prebuilt/ios_arm64/libGemmaModelConstraintProvider.dylib" \
            "GemmaModelConstraintProvider" \
            "${BUILD_DIR}/ios_arm64" \
            "iPhoneOS"
    else
        log_warn "Prebuilt GemmaModelConstraintProvider dylib not found for device"
    fi
    
    log_info "iOS Device build complete: ${BUILD_DIR}/ios_arm64/"
}

# Add Info.plist to a framework if missing or update platform
add_framework_info_plist() {
    local FRAMEWORK_DIR="$1"
    local PLATFORM_NAME="$2"
    local FRAMEWORK_NAME=$(basename "${FRAMEWORK_DIR}" .framework)
    
    log_info "Setting up Info.plist for ${FRAMEWORK_NAME} (${PLATFORM_NAME})..."
    
    cat > "${FRAMEWORK_DIR}/Info.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>en</string>
    <key>CFBundleExecutable</key>
    <string>${FRAMEWORK_NAME}</string>
    <key>CFBundleIdentifier</key>
    <string>com.google.ai.edge.litertlm</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>${FRAMEWORK_NAME}</string>
    <key>CFBundlePackageType</key>
    <string>FMWK</string>
    <key>CFBundleShortVersionString</key>
    <string>0.8.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>CFBundleSupportedPlatforms</key>
    <array>
        <string>${PLATFORM_NAME}</string>
    </array>
    <key>MinimumOSVersion</key>
    <string>13.0</string>
</dict>
</plist>
EOF
}

# Create XCFramework
create_xcframework() {
    log_info "Creating XCFrameworks..."
    
    XCFRAMEWORK_DIR="${BUILD_DIR}/ios_xcframework"
    rm -rf "${XCFRAMEWORK_DIR}"
    mkdir -p "${XCFRAMEWORK_DIR}"
    
    # Check if both framework builds exist
    if [ ! -d "${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework" ]; then
        log_error "Simulator framework not found at ${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework"
        exit 1
    fi
    
    if [ ! -d "${BUILD_DIR}/ios_arm64/LiteRtLm.framework" ]; then
        log_error "Device framework not found at ${BUILD_DIR}/ios_arm64/LiteRtLm.framework"
        exit 1
    fi
    
    # Verify the frameworks have different platform targets
    log_info "Verifying framework architectures..."
    
    SIM_ARCH=$(lipo -archs "${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework/LiteRtLm" 2>/dev/null || echo "unknown")
    DEV_ARCH=$(lipo -archs "${BUILD_DIR}/ios_arm64/LiteRtLm.framework/LiteRtLm" 2>/dev/null || echo "unknown")
    
    log_info "Simulator framework arch: ${SIM_ARCH}"
    log_info "Device framework arch: ${DEV_ARCH}"
    
    # Create LiteRtLm XCFramework
    log_info "Creating LiteRtLm.xcframework..."
    xcodebuild -create-xcframework \
        -framework "${BUILD_DIR}/ios_arm64/LiteRtLm.framework" \
        -framework "${BUILD_DIR}/ios_sim_arm64/LiteRtLm.framework" \
        -output "${XCFRAMEWORK_DIR}/LiteRtLm.xcframework"
    
    if [ $? -ne 0 ]; then
        log_error "Failed to create LiteRtLm.xcframework"
        exit 1
    fi
    
    log_info "LiteRtLm.xcframework created successfully"
    
    # Create GemmaModelConstraintProvider XCFramework if both frameworks exist
    if [ -d "${BUILD_DIR}/ios_arm64/GemmaModelConstraintProvider.framework" ] && \
       [ -d "${BUILD_DIR}/ios_sim_arm64/GemmaModelConstraintProvider.framework" ]; then
        
        log_info "Creating GemmaModelConstraintProvider.xcframework..."
        xcodebuild -create-xcframework \
            -framework "${BUILD_DIR}/ios_arm64/GemmaModelConstraintProvider.framework" \
            -framework "${BUILD_DIR}/ios_sim_arm64/GemmaModelConstraintProvider.framework" \
            -output "${XCFRAMEWORK_DIR}/GemmaModelConstraintProvider.xcframework"
        
        if [ $? -ne 0 ]; then
            log_warn "Failed to create GemmaModelConstraintProvider.xcframework"
        else
            log_info "GemmaModelConstraintProvider.xcframework created successfully"
        fi
    else
        log_warn "GemmaModelConstraintProvider frameworks not found, skipping xcframework creation"
    fi
    
    log_info "XCFrameworks created in: ${XCFRAMEWORK_DIR}/"
    ls -la "${XCFRAMEWORK_DIR}/"
}

# Print usage
usage() {
    echo "Usage: $0 [--simulator|--device|--all] [--litertlm-dir <path>] [--clean]"
    echo ""
    echo "Options:"
    echo "  --simulator      Build for iOS Simulator (arm64, default)"
    echo "  --device         Build for iOS device (arm64)"
    echo "  --all            Build for both and create XCFramework"
    echo "  --litertlm-dir   Path to LiteRT-LM directory (default: ../)"
    echo "  --clean          Clean bazel build caches before building"
    echo ""
    echo "Examples:"
    echo "  $0 --simulator                              # Build for simulator (LiteRT-LM in ../)"
    echo "  $0 --all --litertlm-dir /path/to/LiteRT-LM  # Build both with custom path"
    echo "  $0 --clean --all --litertlm-dir /path/to/LiteRT-LM  # Clean and rebuild"
}

# Main
main() {
    log_info "LiteRT-LM iOS Build Script"
    log_info "iOS App root: ${IOS_APP_ROOT}"

    log_info "LiteRT-LM directory: ${LITERTLM_DIR}"

    # Verify it looks like a LiteRT-LM directory
    if [ ! -f "${LITERTLM_DIR}/c/engine.h" ] || [ ! -f "${LITERTLM_DIR}/WORKSPACE" ]; then
        log_error "Directory does not appear to be a LiteRT-LM workspace: ${LITERTLM_DIR}"
        log_error "Expected to find c/engine.h and WORKSPACE"
        exit 1
    fi

    check_requirements
    setup_xcode_compat

    # Create build directory
    mkdir -p "${BUILD_DIR}"

    # Run builds
    build_simulator
    build_device
    create_xcframework

    log_info "Build complete!"
    log_info ""
    log_info "iOS should be good to go!"
}

main "$@"
